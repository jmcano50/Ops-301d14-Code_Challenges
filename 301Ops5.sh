#!/bin/bash

# Script Name:                  Ops Challenge: Clearing Logs
# Author:                       Juan Miguel Cano
# Date of latest revision:      12/01/2023
# Purpose:                      Create a fake log, compresses it, clears its contents, 
# cont:                         and prints info on the compression process.
# Execution:                    bash 301Ops5.sh
# Resource:                    https://chat.openai.com/share/228c9805-5636-480b-a4cc-fb417f69a0a2
# Resource:                    https://chat.openai.com/share/6a3922e6-1893-40c6-bc7a-567daf834af8
                              

touch "my-log-file.txt" #Creates an empty file named "my-log-file.txt"
echo "Pinto Bean for Dogs generated by Juan ... " >> my-log-file.txt #Appends a line of text to the log file.
cat my-log-file.txt #Prints the contents of the log file to the terminal
mkdir -p "backups"  #Creates a dirctory named "backups" if it doesn't exist.
LOG_FILES=("my-log-file.txt")  #Defines an array containing the name of the log file.
BACKUP_DIR="backups"   #Set the backup directory path to "backups."
TIMESTAMP=$(date +"%m%d%Y")  #Retrieves the current date in the format "MMDDYYY" and assigns it to the variable 'TIMESTAMP'

for file in "${LOG_FILES[@]}"; do #Initiates a loop that iterates over each file in the 'LOG_FILES'array.
    FILE_NAME=$(basename "$file" .txt) #Extracts the base name of the file (removing the extension".txt")and assigns it to the variable 'FILE_NAME'.
    FILE_SIZE=$(wc -c "$file" | awk '{print $1}') #determines the size of the log file and assign it to the variable 'FILE_NAME'.
    zip -r "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" "$file" #Compresses the log file into a zip archive with a filename containing the original file name and the timestamp, storing it in the backup directory.
    cat /dev/null > "$file" #Clears the contents of the original log file.
    COMPRESSED_FILE_SIZE=$(wc -c "$BACKUP_DIR/$FILE_NAME-$TIMESTAMP.zip" | awk '{print $1}') #Determines the size of the compressed file and assigns it to the variable 'COMPRESSED_FILE_SIZE'.

    echo "File size before compression: $FILE_SIZE"
    echo "File size after compression: $COMPRESSED_FILE_SIZE" #Printing information about file sizes and checking if compression was successful based on file sizes.

    if [[ $FILE_SIZE -gt $COMPRESSED_FILE_SIZE ]]; then
        echo "Compression successful: compressed file size is smaller than original file size"
    else
        echo "Compression unsuccessful: compressed file size is larger than original file size"
    fi
done